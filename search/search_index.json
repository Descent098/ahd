{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ahd; Ad-Hoc Dispatcher Create ad-hoc commands to be dispatched in their own namespace. Why? This package seeks to make the tedius task of creating one off bash scripts obsolete. The idea is to write an annoying command once, give it a name, and be able to recall it without an issue. It also has the benefit of namespacing commands that would normally be keywords for ease of use. See the quick-start guide for more details. Features Execution of any valid bash/wsl commands. Specification of multiple paths (including wildcards ) Autocomplete (*nix only; with bash, and plans to add zsh and fish later) A namespace with only 3 reserved keywords (docs, register, config) Cross-platform support \"Limitations\" Autocompletion not supported on windows (not my fault) Technically without vendoring you also can't use ahd as a command for any other purpose Upgrading to V 0.2.x from V0.1.x One thing to note if you are updating to V0.2.x from V0.1.x, the way that the preprocessing of paths works has been changed. Originally it was being stored as a \"list\" (though this isn't actually the case), and now it is just a string of comma-delimited paths. Here are the steps to migrate: Export your current configuration by running: ahd config -e Edit the configuration file in a text editor (in this example I will use nano): nano .ahdconfig Change any paths for commands to string representations instead of lists(remove the square brackets). For example: This [git-upt] command = git pull paths = [C:\\Users\\Kieran\\Desktop\\Development\\personal\\*, C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding\\*] Would become [git-upt] command = git pull paths = ~/Desktop/Development/personal/*, ~/Desktop/Development/Canadian Coding/* \u200b","title":"Home"},{"location":"#ahd-ad-hoc-dispatcher","text":"Create ad-hoc commands to be dispatched in their own namespace.","title":"ahd; Ad-Hoc Dispatcher"},{"location":"#why","text":"This package seeks to make the tedius task of creating one off bash scripts obsolete. The idea is to write an annoying command once, give it a name, and be able to recall it without an issue. It also has the benefit of namespacing commands that would normally be keywords for ease of use. See the quick-start guide for more details.","title":"Why?"},{"location":"#features","text":"Execution of any valid bash/wsl commands. Specification of multiple paths (including wildcards ) Autocomplete (*nix only; with bash, and plans to add zsh and fish later) A namespace with only 3 reserved keywords (docs, register, config) Cross-platform support","title":"Features"},{"location":"#limitations","text":"Autocompletion not supported on windows (not my fault) Technically without vendoring you also can't use ahd as a command for any other purpose","title":"\"Limitations\""},{"location":"#upgrading-to-v-02x-from-v01x","text":"One thing to note if you are updating to V0.2.x from V0.1.x, the way that the preprocessing of paths works has been changed. Originally it was being stored as a \"list\" (though this isn't actually the case), and now it is just a string of comma-delimited paths. Here are the steps to migrate: Export your current configuration by running: ahd config -e Edit the configuration file in a text editor (in this example I will use nano): nano .ahdconfig Change any paths for commands to string representations instead of lists(remove the square brackets). For example: This [git-upt] command = git pull paths = [C:\\Users\\Kieran\\Desktop\\Development\\personal\\*, C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding\\*] Would become [git-upt] command = git pull paths = ~/Desktop/Development/personal/*, ~/Desktop/Development/Canadian Coding/* \u200b","title":"Upgrading to V 0.2.x from V0.1.x"},{"location":"contributing/","text":"Contribution & Development Guide Here is everything you need to know about getting started for contributing to the project (thanks for doing so by the way). Development guide Getting dev dependencies To grab the specified development dependencies simply run pip install adh[dev] , this will grab everything you need. If for some reason this does not work, here are a list of development dependencies: nox # Used to run automated processes pytest # Used to run the test code in the tests directory mkdocs # Used to create HTML versions of the markdown docs in the docs directory Documentation Building user docs If you are contributing to the user documentation (found in /docs) you can verify the documentation by first installing mkdocs ( pip install mkdocs ) then running mkdocs serve and finally going to http://localhost:8000 . Building \"API\" docs API docs are useful if you want an easily navigatable version of the in-line documentation. The best way to do this currently is to download pdoc3 ; pip install pdoc3 then (assuming ahd is installed) run pdoc ahd --http localhost:8080 . Go to a browser and type in http://localhost:8080/ahd . Nox integration If you have never used nox before it is a great system for automating tedius tasks (builds, distributions, testing etc). This project uses nox for a number of things and in the following sections I will explain each. Running tests Testing is implemented using pytest , and can be run 1 of 2 ways: Run the tests through nox using nox -s tests , this will automatically run the tests against python 3.5-3.8 (assuming they are installed on system). Go to the root directory and run pytest , this should automatically detect the /tests folder and run all tests. Building the package This is not necessary for pull requests, or even development but if you want to validate that it doesn't break buildability here is how to do it. You can use nox -s build , this will create a source distribution for you using pythons setuptools module . Contribution guide TLDR Commenting/documentaion is not optional Breaking platform compatability is not acceptable Do everything through github (don't email me), and (mostly) everything has been setup for you. Bug Reports & Feature Requests Submit all bug reports and feature requests on github , the format for each is pre-defined so just follow the outlined format Pull requests Pull requests should be submitted through github and follow the default pull request template specified. If you want the rundown of what needs to be present: Provide a clear explination of what you are doing/fixing Feature is tested on Windows & *nix (unless explicitly incompatable) All Classes, modules, and functions must have docstrings that follow the numpy-style guide . Unless feature is essential it cannot break backwards compatability","title":"Contributing"},{"location":"contributing/#contribution-development-guide","text":"Here is everything you need to know about getting started for contributing to the project (thanks for doing so by the way).","title":"Contribution &amp; Development Guide"},{"location":"contributing/#development-guide","text":"","title":"Development guide"},{"location":"contributing/#getting-dev-dependencies","text":"To grab the specified development dependencies simply run pip install adh[dev] , this will grab everything you need. If for some reason this does not work, here are a list of development dependencies: nox # Used to run automated processes pytest # Used to run the test code in the tests directory mkdocs # Used to create HTML versions of the markdown docs in the docs directory","title":"Getting dev dependencies"},{"location":"contributing/#documentation","text":"","title":"Documentation"},{"location":"contributing/#building-user-docs","text":"If you are contributing to the user documentation (found in /docs) you can verify the documentation by first installing mkdocs ( pip install mkdocs ) then running mkdocs serve and finally going to http://localhost:8000 .","title":"Building user docs"},{"location":"contributing/#building-api-docs","text":"API docs are useful if you want an easily navigatable version of the in-line documentation. The best way to do this currently is to download pdoc3 ; pip install pdoc3 then (assuming ahd is installed) run pdoc ahd --http localhost:8080 . Go to a browser and type in http://localhost:8080/ahd .","title":"Building \"API\" docs"},{"location":"contributing/#nox-integration","text":"If you have never used nox before it is a great system for automating tedius tasks (builds, distributions, testing etc). This project uses nox for a number of things and in the following sections I will explain each.","title":"Nox integration"},{"location":"contributing/#running-tests","text":"Testing is implemented using pytest , and can be run 1 of 2 ways: Run the tests through nox using nox -s tests , this will automatically run the tests against python 3.5-3.8 (assuming they are installed on system). Go to the root directory and run pytest , this should automatically detect the /tests folder and run all tests.","title":"Running tests"},{"location":"contributing/#building-the-package","text":"This is not necessary for pull requests, or even development but if you want to validate that it doesn't break buildability here is how to do it. You can use nox -s build , this will create a source distribution for you using pythons setuptools module .","title":"Building the package"},{"location":"contributing/#contribution-guide","text":"","title":"Contribution guide"},{"location":"contributing/#tldr","text":"Commenting/documentaion is not optional Breaking platform compatability is not acceptable Do everything through github (don't email me), and (mostly) everything has been setup for you.","title":"TLDR"},{"location":"contributing/#bug-reports-feature-requests","text":"Submit all bug reports and feature requests on github , the format for each is pre-defined so just follow the outlined format","title":"Bug Reports &amp; Feature Requests"},{"location":"contributing/#pull-requests","text":"Pull requests should be submitted through github and follow the default pull request template specified. If you want the rundown of what needs to be present: Provide a clear explination of what you are doing/fixing Feature is tested on Windows & *nix (unless explicitly incompatable) All Classes, modules, and functions must have docstrings that follow the numpy-style guide . Unless feature is essential it cannot break backwards compatability","title":"Pull requests"},{"location":"faq/","text":"Frequently Asked Questions If you have any questions feel free to submit an issue on github using the question template . I made a mistake when registering a command, how do I change it? There are two options: You can re-register the command; anytime a command is registered that has the name of an existing command it will overwrite the existing command. You can manually edit the configuration by running ahd config -e then modifying the .ahdconfig file that shows up in your current directory and reimport it using ahd config -i .ahdconfig . I'm getting a permission error when I try to register a command, what do I do? On *nix systems I have intentionally made it so you MUST use sudo when registering a command, or importing a config. Since ahd dispatches literally whatever you type, I have made it so you need admin privileges to make configuration modifications. I'm getting a permission error when I try to run a command, what do I do? Likely the command you have registered needs sudo access, modify your configuration using one of the methods found in the first question of this page and add sudo in front of the command.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"If you have any questions feel free to submit an issue on github using the question template .","title":"Frequently Asked Questions"},{"location":"faq/#i-made-a-mistake-when-registering-a-command-how-do-i-change-it","text":"There are two options: You can re-register the command; anytime a command is registered that has the name of an existing command it will overwrite the existing command. You can manually edit the configuration by running ahd config -e then modifying the .ahdconfig file that shows up in your current directory and reimport it using ahd config -i .ahdconfig .","title":"I made a mistake when registering a command, how do I change it?"},{"location":"faq/#im-getting-a-permission-error-when-i-try-to-register-a-command-what-do-i-do","text":"On *nix systems I have intentionally made it so you MUST use sudo when registering a command, or importing a config. Since ahd dispatches literally whatever you type, I have made it so you need admin privileges to make configuration modifications.","title":"I'm getting a permission error when I try to register a command, what do I do?"},{"location":"faq/#im-getting-a-permission-error-when-i-try-to-run-a-command-what-do-i-do","text":"Likely the command you have registered needs sudo access, modify your configuration using one of the methods found in the first question of this page and add sudo in front of the command.","title":"I'm getting a permission error when I try to run a command, what do I do?"},{"location":"quick-start/","text":"Quick-start Everything you need to know to get started using ahd. Installation From Pypi Run pip install ahd or sudo pip3 install ahd From source Clone the repo: ( https://github.com/Descent098/ahd ) Run pip install . or sudo pip3 install . in the root directory Example In this example I will show you how to setup a name called rmtmp that when called will delete all files in the ~/tmp folder. First for any command you will need to register it, registering is in the form of ahd register <name> [<command>] [<paths>] so for this example: ahd register rmtmp \"rm *\" \"~/tmp\" Now to run the command you use the form ahd <name> , so in this case: ahd rmtmp This will effectively run cd ~/tmp && rm * then cd back to your current directory. Although this is a toy example it allows you to specify the execution of what would normally be tedius commands from anywhere. If you are looking for some more robust examples check out the usage section.","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"Everything you need to know to get started using ahd.","title":"Quick-start"},{"location":"quick-start/#installation","text":"","title":"Installation"},{"location":"quick-start/#from-pypi","text":"Run pip install ahd or sudo pip3 install ahd","title":"From Pypi"},{"location":"quick-start/#from-source","text":"Clone the repo: ( https://github.com/Descent098/ahd ) Run pip install . or sudo pip3 install . in the root directory","title":"From source"},{"location":"quick-start/#example","text":"In this example I will show you how to setup a name called rmtmp that when called will delete all files in the ~/tmp folder. First for any command you will need to register it, registering is in the form of ahd register <name> [<command>] [<paths>] so for this example: ahd register rmtmp \"rm *\" \"~/tmp\" Now to run the command you use the form ahd <name> , so in this case: ahd rmtmp This will effectively run cd ~/tmp && rm * then cd back to your current directory. Although this is a toy example it allows you to specify the execution of what would normally be tedius commands from anywhere. If you are looking for some more robust examples check out the usage section.","title":"Example"},{"location":"usage/","text":"Usage Usage: ahd [-h] [-v] [-d] ahd docs [-a] [-o] ahd config [-e] [-i CONFIG_FILE_PATH] ahd register <name> [<command>] [<paths>] ahd <name> [<command>] [<paths>] Options: -h, --help show this help message and exit -v, --version show program's version number and exit -a, --api shows the local API docs -o, --offline shows the local User docs instead of live ones -e, --export exports the configuration file -i CONFIG_FILE_PATH, --import CONFIG_FILE_PATH imports the configuration file Example Here is a quick example of creating a command that runs sudo apt-get update && sudo apt-get upgrade : Register the command as the name \"update\": ahd register update \"sudo apt-get update && sudo apt-get upgrade\" Run the command using the name \"update\": ahd update This example was somewhat trivial but keep in mind this effectively means you can replace any short bash scripts you are using to do things like updating multiple git repos, executing a sequence of commands to sort your downloads folder etc. Arguments docs The docs command is designed to bring up documentation as needed, you can run ahd docs to open the documentation site in the default browser. Options : -a --api: Used to serve local API documentation (Not yet implemented) -o --offline: Used to serve local user documentation (Not yet implemented) config This command is used for all configuration management. Due to the amount of preprocessing involved in keeping ahd cross platform the dotfile is obstructed from view by default. The config command is the main interface for managing configurations manually though I would recommend using the register command as opposed to this, or looking at the documentation for details about manual configuration . Options : -e --export: Export the current configuration file (it's a dotfile so make sure view hidden files is enabled) -i --import: Import a configuration file; takes the path as an argument Register The register command allows you to register a name to be used later on. For example if I wanted to create a command that dispatched running git pull in several of my directories that is activated when I type ahd git-upt then I can just run ahd register git-upt \"git pull\" \"~/path/to/project, ~/path/to/project-2, ~/path/to/project-3 <name> This is a placeholder value for the name of a command you have registered. Once the command is registered you can run it by using ahd <name> , additionally you can override the default set commands or paths, details can be found below. Overriding You can override the registered command, or paths of a name ad-hoc. Overriding can be useful in circumstances where you may want to vary the command or paths being run. This also means that on top of running commands you can use ahd to specify a set of paths to execure ad-hoc commands to. Here are some examples of both. Commands Let's say you have registered the name \"environments\", this contains all the paths to the root directories of application instances you have running on a server. For example: ahd register environments \"\" \"~/path/to/application, ~/path/to/application-2, ~/path/to/application-3\" You'll notice I left the command blank since it will be overriden anyway later on. You can now use command overriding to run commands accross all of your application instances. In this example let's say you wanted to pull the latest git code on all the application instances, you could just use: ahd environments \"git pull\" Since only the <command> is being overridden ahd will execute \"git pull\" in all the specified paths. Paths Overriding paths is a bit more esoteric, there is a built-in mechanism that allows you to skip command overriding and specify a new path. Let's take the following example of running docker compose up in various paths. First register the command with a name, in this case we will call it \"buildapp\": ahd register buildapp \"docker compose up\" \".\" This means by default if we run ahd buildapp it will run in the same directory you are in, but we could override the paths and execute it in multiple places. The way this works is by \"overriding\" the command to \".\" this is a built-in convention that means \"skip overridding the command value for now\". In this case we could run: ahd buildapp \".\" \"~/path/to/application, ~/path/to/application-2, ~/path/to/application-3\" to execute docker compose up in all 3 locations. Wildcards and Cross platform paths In ahd paths are normalized across os's and wildcards are supported. Platform normalization steps TL;DR : use unix-style paths (/ and include ~ for the home directory) even on windows. The long version : Paths in ahd are automatically platform agnostic (unless you manually edit the config file). This means that when you register a command in windows the paths are preprocessed to change \\ to / in the config file, and ~ to the USERPROFILE environment variable, then postprocessed back when running commands. Functionally this means you can use the exact same configuration across platforms if you use the unix path idiosyncrasies (~ and /). Wildcards Additionally you can specify wildcards to say \"all directories in a given pattern\". Under the hood this is done through the glob module in python (note there must be an asterisk or else it will register as a literal character), but the basics are that an asterisk delimits \"any directory\". So for example if you wanted to register a command to \"git pull\" all folders in a directory you could use: ahd register git-upt \"git pull\" \"C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding\\*\" Here is the tree for C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding : C:\\USERS\\KIERAN\\DESKTOP\\DEVELOPMENT\\CANADIAN CODING \u251c\u2500\u2500\u2500posts \u251c\u2500\u2500\u2500SSB \u251c\u2500\u2500\u2500website So this means that when you run ahd git-upt it will run the same as: cd C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding\\posts && git pull cd C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding\\SSB && git pull cd C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding\\website && git pull Manually editing paths in config All paths should be specified in unix style (use / instead of \\), even if intended to be used on windows. This is because the preprocessor that happens when you register a command does this for you. Autocompletion on ZSH, fish etc. There are plans to fully support zsh and fish in the future, but a temporary solution is to use a module called docopt-completion (install using pip install infi.docopt-completion ). Once installed you can run docopt-completion ahd to generate autocompletion on the TOP-LEVEL (register, docs, config) commands. Unfortunately there is no solution for autocompletion on ahd registered commands (yet).","title":"Usage"},{"location":"usage/#usage","text":"Usage: ahd [-h] [-v] [-d] ahd docs [-a] [-o] ahd config [-e] [-i CONFIG_FILE_PATH] ahd register <name> [<command>] [<paths>] ahd <name> [<command>] [<paths>] Options: -h, --help show this help message and exit -v, --version show program's version number and exit -a, --api shows the local API docs -o, --offline shows the local User docs instead of live ones -e, --export exports the configuration file -i CONFIG_FILE_PATH, --import CONFIG_FILE_PATH imports the configuration file","title":"Usage"},{"location":"usage/#example","text":"Here is a quick example of creating a command that runs sudo apt-get update && sudo apt-get upgrade : Register the command as the name \"update\": ahd register update \"sudo apt-get update && sudo apt-get upgrade\" Run the command using the name \"update\": ahd update This example was somewhat trivial but keep in mind this effectively means you can replace any short bash scripts you are using to do things like updating multiple git repos, executing a sequence of commands to sort your downloads folder etc.","title":"Example"},{"location":"usage/#arguments","text":"","title":"Arguments"},{"location":"usage/#docs","text":"The docs command is designed to bring up documentation as needed, you can run ahd docs to open the documentation site in the default browser. Options : -a --api: Used to serve local API documentation (Not yet implemented) -o --offline: Used to serve local user documentation (Not yet implemented)","title":"docs"},{"location":"usage/#config","text":"This command is used for all configuration management. Due to the amount of preprocessing involved in keeping ahd cross platform the dotfile is obstructed from view by default. The config command is the main interface for managing configurations manually though I would recommend using the register command as opposed to this, or looking at the documentation for details about manual configuration . Options : -e --export: Export the current configuration file (it's a dotfile so make sure view hidden files is enabled) -i --import: Import a configuration file; takes the path as an argument","title":"config"},{"location":"usage/#register","text":"The register command allows you to register a name to be used later on. For example if I wanted to create a command that dispatched running git pull in several of my directories that is activated when I type ahd git-upt then I can just run ahd register git-upt \"git pull\" \"~/path/to/project, ~/path/to/project-2, ~/path/to/project-3","title":"Register"},{"location":"usage/#name62","text":"This is a placeholder value for the name of a command you have registered. Once the command is registered you can run it by using ahd <name> , additionally you can override the default set commands or paths, details can be found below.","title":"&lt;name>"},{"location":"usage/#overriding","text":"You can override the registered command, or paths of a name ad-hoc. Overriding can be useful in circumstances where you may want to vary the command or paths being run. This also means that on top of running commands you can use ahd to specify a set of paths to execure ad-hoc commands to. Here are some examples of both.","title":"Overriding"},{"location":"usage/#commands","text":"Let's say you have registered the name \"environments\", this contains all the paths to the root directories of application instances you have running on a server. For example: ahd register environments \"\" \"~/path/to/application, ~/path/to/application-2, ~/path/to/application-3\" You'll notice I left the command blank since it will be overriden anyway later on. You can now use command overriding to run commands accross all of your application instances. In this example let's say you wanted to pull the latest git code on all the application instances, you could just use: ahd environments \"git pull\" Since only the <command> is being overridden ahd will execute \"git pull\" in all the specified paths.","title":"Commands"},{"location":"usage/#paths","text":"Overriding paths is a bit more esoteric, there is a built-in mechanism that allows you to skip command overriding and specify a new path. Let's take the following example of running docker compose up in various paths. First register the command with a name, in this case we will call it \"buildapp\": ahd register buildapp \"docker compose up\" \".\" This means by default if we run ahd buildapp it will run in the same directory you are in, but we could override the paths and execute it in multiple places. The way this works is by \"overriding\" the command to \".\" this is a built-in convention that means \"skip overridding the command value for now\". In this case we could run: ahd buildapp \".\" \"~/path/to/application, ~/path/to/application-2, ~/path/to/application-3\" to execute docker compose up in all 3 locations.","title":"Paths"},{"location":"usage/#wildcards-and-cross-platform-paths","text":"In ahd paths are normalized across os's and wildcards are supported.","title":"Wildcards and Cross platform paths"},{"location":"usage/#platform-normalization-steps","text":"TL;DR : use unix-style paths (/ and include ~ for the home directory) even on windows. The long version : Paths in ahd are automatically platform agnostic (unless you manually edit the config file). This means that when you register a command in windows the paths are preprocessed to change \\ to / in the config file, and ~ to the USERPROFILE environment variable, then postprocessed back when running commands. Functionally this means you can use the exact same configuration across platforms if you use the unix path idiosyncrasies (~ and /).","title":"Platform normalization steps"},{"location":"usage/#wildcards","text":"Additionally you can specify wildcards to say \"all directories in a given pattern\". Under the hood this is done through the glob module in python (note there must be an asterisk or else it will register as a literal character), but the basics are that an asterisk delimits \"any directory\". So for example if you wanted to register a command to \"git pull\" all folders in a directory you could use: ahd register git-upt \"git pull\" \"C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding\\*\" Here is the tree for C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding : C:\\USERS\\KIERAN\\DESKTOP\\DEVELOPMENT\\CANADIAN CODING \u251c\u2500\u2500\u2500posts \u251c\u2500\u2500\u2500SSB \u251c\u2500\u2500\u2500website So this means that when you run ahd git-upt it will run the same as: cd C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding\\posts && git pull cd C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding\\SSB && git pull cd C:\\Users\\Kieran\\Desktop\\Development\\Canadian Coding\\website && git pull","title":"Wildcards"},{"location":"usage/#manually-editing-paths-in-config","text":"All paths should be specified in unix style (use / instead of \\), even if intended to be used on windows. This is because the preprocessor that happens when you register a command does this for you.","title":"Manually editing paths in config"},{"location":"usage/#autocompletion-on-zsh-fish-etc","text":"There are plans to fully support zsh and fish in the future, but a temporary solution is to use a module called docopt-completion (install using pip install infi.docopt-completion ). Once installed you can run docopt-completion ahd to generate autocompletion on the TOP-LEVEL (register, docs, config) commands. Unfortunately there is no solution for autocompletion on ahd registered commands (yet).","title":"Autocompletion on ZSH, fish etc."}]}